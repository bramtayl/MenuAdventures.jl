var documenterSearchIndex = {"docs":
[{"location":"Outfits/#Outfits","page":"Outfits extension","title":"Outfits","text":"","category":"section"},{"location":"Outfits/","page":"Outfits extension","title":"Outfits extension","text":"Pages = [\"Outfits.md\"]","category":"page"},{"location":"Outfits/","page":"Outfits extension","title":"Outfits extension","text":"Modules = [MenuAdventures.Outfits]","category":"page"},{"location":"Outfits/#MenuAdventures.Outfits","page":"Outfits extension","title":"MenuAdventures.Outfits","text":"MenuAdventures.Outfits\n\nA sub-module that enables the player to wear clothes.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Outfits\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Clothes <: Noun\n        end;\n\njulia> ever_possible(::Dress, ::Inventory, ::Clothes) = true;\n\njulia> ever_possible(::Take, ::Reachable, ::Clothes) = true;\n\njulia> ever_possible(::Dress, ::Reachable, ::Person) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Outfits\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                coat = Clothes(\"coat\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, Clothes(\"coat\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Outfits/#MenuAdventures.Outfits.Dress","page":"Outfits extension","title":"MenuAdventures.Outfits.Dress","text":"Dress()\n\nDress someone Reachable in something from your Inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Outfits/#MenuAdventures.Outfits.Wearing","page":"Outfits extension","title":"MenuAdventures.Outfits.Wearing","text":"Wearing()\n\nA is Wearing B means B is worn by A.\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"Talking/#Talking","page":"Talking extension","title":"Talking","text":"","category":"section"},{"location":"Talking/","page":"Talking extension","title":"Talking extension","text":"Pages = [\"Talking.md\"]","category":"page"},{"location":"Talking/","page":"Talking extension","title":"Talking extension","text":"Modules = [MenuAdventures.Talking]","category":"page"},{"location":"Talking/#MenuAdventures.Talking","page":"Talking extension","title":"MenuAdventures.Talking","text":"MenuAdventures.Talking\n\nA sub-module that enables talking to other players.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Talking\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct NPC <: Noun\n            dialog::Dict{String, Answer} = Dict{String, Answer}()\n        end;\n\njulia> ever_possible(::Say, ::Visible, ::NPC) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Talking\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                friend = NPC(\n                    \"your friend\",\n                    indefinite_article = \"\",\n                    dialog = Dict(\"Hello\" => Answer(\"Hello\", (universe, person) -> nothing))\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, friend] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Talking/#MenuAdventures.Talking.Dialog","page":"Talking extension","title":"MenuAdventures.Talking.Dialog","text":"Dialog()\n\nThings a player might say.\n\nFor dialog, the keys will be things you can say, and answers will be replies. The text of answer objects will be the quoted version of their object.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"Talking/#MenuAdventures.Talking.Say","page":"Talking extension","title":"MenuAdventures.Talking.Say","text":"Say()\n\nSay, to someone Visible, some Dialog.\n\nAn Action.  Note the first argument is the addressee, and the second is the dialog. If possible(::Say, ::Dialog, addressee), then addressee must have a dialog field containing a dialog dictionary. The keys of this dictionary should be text the player says, and the values should be Answers containing a response from the addressee and a trigger. After a dialog option is chosen, the response trigger will be called with two arguments: universe and addressee. Then the dialog option will be removed.\n\n\n\n\n\n","category":"type"},{"location":"Parts/#Parts","page":"Parts extension","title":"Parts","text":"","category":"section"},{"location":"Parts/","page":"Parts extension","title":"Parts extension","text":"Pages = [\"Parts.md\"]","category":"page"},{"location":"Parts/","page":"Parts extension","title":"Parts extension","text":"Modules = [MenuAdventures.Parts]","category":"page"},{"location":"Parts/#MenuAdventures.Parts","page":"Parts extension","title":"MenuAdventures.Parts","text":"MenuAdventures.Parts\n\nA sub-module that allows things to be part of other things.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Parts\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct StickyThing <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::StickyThing) = true;\n\njulia> ever_possible(::Attach, ::Inventory, ::StickyThing) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Parts\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, StickyThing(\"sticky thing\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Parts/#MenuAdventures.Parts.Attach","page":"Parts extension","title":"MenuAdventures.Parts.Attach","text":"Attach()\n\nAttach something from your Inventory to something else Reachable.\n\nAn Action.  By default, ever_possible(::Attach, ::Reachable, _) = true, that is, you can attach something sticky to anything.\n\n\n\n\n\n","category":"type"},{"location":"Parts/#MenuAdventures.Parts.Incorporating","page":"Parts extension","title":"MenuAdventures.Parts.Incorporating","text":"Incorporating()\n\nA is Incorporating B means B is part of A\"\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"ExtraActions/#ExtraActions","page":"ExtraActions extension","title":"ExtraActions","text":"","category":"section"},{"location":"ExtraActions/","page":"ExtraActions extension","title":"ExtraActions extension","text":"Pages = [\"ExtraActions.md\"]","category":"page"},{"location":"ExtraActions/","page":"ExtraActions extension","title":"ExtraActions extension","text":"Modules = [MenuAdventures.ExtraActions]","category":"page"},{"location":"ExtraActions/#MenuAdventures.ExtraActions","page":"ExtraActions extension","title":"MenuAdventures.ExtraActions","text":"MenuAdventures.ExtraActions\n\nA sub-module with miscellaneous extra actions.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.ExtraActions\n\njulia> import MenuAdventures: ever_possible, is_shining\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> ever_possible(::Give, ::Reachable, ::Person) = true;\n\njulia> @noun struct Food <: Noun\n        end;\n\njulia> ever_possible(::Eat, ::Reachable, ::Food) = true;\n\njulia> @noun mutable struct Lamp <: Noun\n            on::Bool = false\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Lamp) = true;\n\njulia> ever_possible(::TurnOnOrOff, ::Reachable, ::Lamp) = true;\n\njulia> is_shining(thing::Lamp) = thing.on;\n\njulia> @noun struct Anvil <: Noun\n        end;\n\njulia> ever_possible(::PushBetweenRooms, ::Immediate, ::Anvil) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"ExtraActions\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                light_room = Room(\"light room\")\n                dark_room = Room(\"dark room\", already_lit = false)\n                universe = Universe(you, interface = interface)\n                universe[light_room, dark_room] = North()\n                universe[light_room, you] = Containing()\n                universe[light_room, Person(\"friend\")] = Containing()\n                universe[light_room, Lamp(\"lamp\")] = Containing()\n                universe[light_room, Food(\"food\")] = Containing()\n                universe[light_room, Anvil(\"anvil\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"ExtraActions/#MenuAdventures.ExtraActions.Eat","page":"ExtraActions extension","title":"MenuAdventures.ExtraActions.Eat","text":"Eat()\n\nEat something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"ExtraActions/#MenuAdventures.ExtraActions.Give","page":"ExtraActions extension","title":"MenuAdventures.ExtraActions.Give","text":"Give()\n\nGive something from your Inventory to someone Reachable.\n\nAn Action. By default, ever_possible(::Give, ::Inventory, _) = true, that is, you can give someone anything in your inventory.\n\n\n\n\n\n","category":"type"},{"location":"ExtraActions/#MenuAdventures.ExtraActions.PushBetweenRooms","page":"ExtraActions extension","title":"MenuAdventures.ExtraActions.PushBetweenRooms","text":"PushBetweenRooms()\n\nPush something Immediate in one of ExitDirections.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"ExtraActions/#MenuAdventures.ExtraActions.TurnOnOrOff","page":"ExtraActions extension","title":"MenuAdventures.ExtraActions.TurnOnOrOff","text":"TurnOnOrOff()\n\nTurn on or off something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Testing/#Testing","page":"Testing extension","title":"Testing","text":"","category":"section"},{"location":"Testing/","page":"Testing extension","title":"Testing extension","text":"Pages = [\"Testing.md\"]","category":"page"},{"location":"Testing/","page":"Testing extension","title":"Testing extension","text":"Modules = [MenuAdventures.Testing]","category":"page"},{"location":"Testing/#MenuAdventures.Testing.check_choices-Tuple{Any}","page":"Testing extension","title":"MenuAdventures.Testing.check_choices","text":"check_choices(make_universe;\n    choices_file = \"choices.txt\", \n    transcript_file = \"transcript.txt\"\n)\n\nCheck the results of choices against a transcript created with save_choices.\n\nReturn true if the results match, false otherwise. make_universe should be a function which takes one argument, an IO interface, and returns an [AbstractUniverse]. choices_file will be the delimited file where user choices were saved. transcript_file will be the file where the game transcript was saved.\n\n\n\n\n\n","category":"method"},{"location":"Testing/#MenuAdventures.Testing.save_choices-Tuple{Any}","page":"Testing extension","title":"MenuAdventures.Testing.save_choices","text":"save_choices(make_universe;\n    choices_file = \"choices.txt\", \n    transcript_file = \"transcript.txt\",\n    resume = false\n)\n\nSave the choices a user makes as a delimited file, as well as the transcript of the game.\n\nUse to create a transcript to test with check_choices. make_universe should be a function which takes one argument, an IO interface, and returns an AbstractUniverse. choices_file will be the delimited file where user choices are saved. transcript_file will be the file where the game transcript will be saved. If resume is true, the game will pick up from the point you left off, based on the existing choices_file.\n\n\n\n\n\n","category":"method"},{"location":"Onto/#Onto","page":"Onto extension","title":"Onto","text":"","category":"section"},{"location":"Onto/","page":"Onto extension","title":"Onto extension","text":"Pages = [\"Onto.md\"]","category":"page"},{"location":"Onto/","page":"Onto extension","title":"Onto extension","text":"Modules = [MenuAdventures.Onto]","category":"page"},{"location":"Onto/#MenuAdventures.Onto","page":"Onto extension","title":"MenuAdventures.Onto","text":"MenuAdventures.Onto\n\nA sub-module that allows things to be on top of other things.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Onto\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Thing <: Noun\n        end;\n\njulia> @noun struct Table <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Thing) = true;\n\njulia> ever_possible(::PutOnto, ::Reachable, ::Table) = true;\n\njulia> ever_possible(::GoOnto, ::Immediate, ::Table) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Onto\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, Table(\"table\")] = Containing()\n                universe[room, Thing(\"thing\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Onto/#MenuAdventures.Onto.GoOnto","page":"Onto extension","title":"MenuAdventures.Onto.GoOnto","text":"GoOnto()\n\nGo onto something Immediate.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Onto/#MenuAdventures.Onto.PutOnto","page":"Onto extension","title":"MenuAdventures.Onto.PutOnto","text":"PutOnto()\n\nPut something from your Inventory onto something Reachable.\n\nAn Action. By default, ever_possible(::PutOnto, ::Inventory, _) = true, that is, you can always put something from your inventory onto a surface.\n\n\n\n\n\n","category":"type"},{"location":"Onto/#MenuAdventures.Onto.Supporting","page":"Onto extension","title":"MenuAdventures.Onto.Supporting","text":"Supporting()\n\nA is Supporting B means B is on top of A.\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"#Public-interface","page":"Basic Interface","title":"Public interface","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"MenuAdventures","category":"page"},{"location":"#MenuAdventures","page":"Basic Interface","title":"MenuAdventures","text":"MenuAdventures\n\nA module for creating text adventures based on menus.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> import MenuAdventures: ever_possible, is_transparent, is_vehicle\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Key <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Key) = true;\n\njulia> ever_possible(::UnlockOrLock, ::Inventory, ::Key) = true;\n\njulia> @noun mutable struct LockableDoor <: AbstractDoor\n            key::Noun\n            closed::Bool = true\n            locked::Bool = true\n        end;\n\njulia> ever_possible(::OpenOrClose, ::Reachable, ::LockableDoor) = true;\n\njulia> ever_possible(::UnlockOrLock, ::Reachable, ::LockableDoor) = true;\n\njulia> @noun struct Basket <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Basket) = true;\n\njulia> ever_possible(::PutInto, ::Reachable, ::Basket) = true;\n\njulia> @noun struct Car <: Noun\n        end;\n\njulia> ever_possible(::GoInto, ::Immediate, ::Car) = true;\n\njulia> is_transparent(::Car) = true;\n\njulia> is_vehicle(::Car) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    description = (universe, self) -> \"What a dork!\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                entrance = Room(\n                    \"the entrance\",\n                    description = (universe, self) -> \"The entrance to the castle\",\n                    indefinite_article = \"\"\n                )\n                right_key = Key(\"the right key\", indefinite_article = \"\")\n                universe = Universe(\n                    you,\n                    introduction = \"Welcome!\",\n                    interface = interface\n                )\n                universe[entrance, Room(\"the castle\", indefinite_article = \"\")] = LockableDoor(\"door\", right_key), West()\n                universe[entrance, you] = Containing()\n                universe[entrance, right_key] = Containing()\n                universe[entrance, Key(\"the wrong key\", indefinite_article = \"\")] = Containing()\n                universe[entrance, Basket(\"basket\")] = Containing()\n                universe[entrance, Car(\"car\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#Core-interface","page":"Basic Interface","title":"Core interface","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"AbstractDoor\nAbstractRoom\nAbstractUniverse\nAnswer\nDirection\nDomain\nLocation\nNoun\n@noun\nRelationship\nSentence\nturn!\n@universe","category":"page"},{"location":"#MenuAdventures.AbstractDoor","page":"Basic Interface","title":"MenuAdventures.AbstractDoor","text":"abstract type AbstractDoor <: Location end\n\nAn abstract door\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.AbstractRoom","page":"Basic Interface","title":"MenuAdventures.AbstractRoom","text":"abstract type AbstractRoom <: Location end\n\nAn abstract room.\n\nIn addition to the required fields for @noun, you must also include an already_lit::Bool field for an AbstractRoom.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.AbstractUniverse","page":"Basic Interface","title":"MenuAdventures.AbstractUniverse","text":"abstract type AbstractUniverse end\n\nContains all the information about the game universe.\n\nYou will need to create your own AbstractUniverse subtype. See @universe for an easy way to do this.\n\nThe universe is organized as an interlinking web of Locations connected by Directions. Each location is the root of a tree of Nouns connected by Relationships.\n\nYou can add a new thing to the universe, or change the location of something, by specifying its relation to another thing:\n\nuniverse[parent_thing, thing] = relationship\n\nYou can add a connection between locations too, optionally interspersed by a door:\n\nuniverse[origin, destination, one_way = false] = direction\nuniverse[origin, destination, one_way = false] = door, direction\n\nBy default, this will create a way back in the MenuAdventures.opposite direction. To suppress this, set one_way = true\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Answer","page":"Basic Interface","title":"MenuAdventures.Answer","text":"Answer(text::String, object::Any)\n\nAn answer has two fields: text, which will be how the option is displayed in a menu, and object.\n\nobject might be a noun, direction, trigger, or even a question.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Direction","page":"Basic Interface","title":"MenuAdventures.Direction","text":"abstract type Direction end\n\nDirections show the relationships between Locations.\n\nFor example, a place can be North of another place. To create a new Direction, you must add a method for\n\nBase.show\nthe MenuAdventures.opposite of the direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Domain","page":"Basic Interface","title":"MenuAdventures.Domain","text":"abstract type Domain end\n\nA domain refers to a search space for a specific argument to an Action.\n\nDomains serve both as a way of distinguishing different arguments to an action, and also, categorizing the environment around the player. For example, you are only able to look at things in the Visible domain. To create a new domain, you must add a method for:\n\nMenuAdventures.find_in_domain\nMenuAdventures.indefinite\nMenuAdventures.interrogative\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Location","page":"Basic Interface","title":"MenuAdventures.Location","text":"abstract type Location <: Noun end\n\nA location (room or door)\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Noun","page":"Basic Interface","title":"MenuAdventures.Noun","text":"abstract type Noun end\n\nYou must make your own custom Noun subtypes for almost everything in your game. \n\nSee @noun for information about required fields. Nouns are additionally characterized by the following traits and methods:\n\nMenuAdventures.ever_possible\nMenuAdventures.is_shining\nMenuAdventures.is_transparent\nMenuAdventures.is_vehicle\n\nThe following IOContext components will be respected when showing nouns:\n\n:capitalize::Bool => false\n:known::Bool => true, set to false to include the indefinite article if it exists.\n:is_subject => true, whether the noun is the subject of a clause. If this is set to false, you must also include\n:subject::Noun, the subject of the clause.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.@noun","page":"Basic Interface","title":"MenuAdventures.@noun","text":"@noun user_definition\n\nAutomatically add the required fields to a Noun struct definition, including sane defaults.\n\nAdds the following fields and defaults:\n\nname::String\nplural::Bool = false\ngrammatical_person::GrammaticalPerson = third_person, see third_person\nindefinite_article::String = \"a\"\ndescription = (universe, self) -> \"\"\n\nSet indefinite_article to \"\" for proper nouns. description should be a function which takes two arguments, the universe and the thing itself, and returns a description.\n\n\n\n\n\n","category":"macro"},{"location":"#MenuAdventures.Relationship","page":"Basic Interface","title":"MenuAdventures.Relationship","text":"abstract type Relationship end\n\nRelationships show the relationships between Nouns. \n\nFor example, something can be Containing something else.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Sentence","page":"Basic Interface","title":"MenuAdventures.Sentence","text":"Sentence(action::Action; argument_answers = Answer[])\n\nA sentence has two fields: action, the Action to be taken, and argument_answers, the arguments to the action. \n\nArguments will be returned as Answers. The subject is implicitly universe.player.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.turn!","page":"Basic Interface","title":"MenuAdventures.turn!","text":"turn!(universe; introduce = true)\n\nStart a turn in the AbstractUniverse, and keep going until an Action returns true.\n\nYou can overload turn! for an AbstractUniverse. Use Base.invoke to avoid replicating the turn! machinery.\n\n\n\n\n\n","category":"function"},{"location":"#MenuAdventures.@universe","page":"Basic Interface","title":"MenuAdventures.@universe","text":"@universe user_definition\n\nAutomatically add the required fields to an AbstractUniverse struct definition, including sane defaults.\n\nAdds the following fields and defaults:\n\nplayer::Noun. The player will typically be in second_person.\ninterface::TTYTerminal = terminal\nintroduction::String = \"\"\nrelationships_graph = MetaGraph(DiGraph(), Label = Noun, EdgeMeta = Relationship)), the Relationships between Nouns.\ndirections_graph = MetaGraph(DiGraph(), Label = Location, EdgeMeta = Direction)), the Directions between Locations.\nchoices_log::Vector{Int} = Int[] saves all choices the user makes\n\nSee AbstractUniverse for more information.\n\n\n\n\n\n","category":"macro"},{"location":"#Directions","page":"Basic Interface","title":"Directions","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"North\nSouth\nEast\nWest","category":"page"},{"location":"#MenuAdventures.North","page":"Basic Interface","title":"MenuAdventures.North","text":"North()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.South","page":"Basic Interface","title":"MenuAdventures.South","text":"South()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.East","page":"Basic Interface","title":"MenuAdventures.East","text":"East()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.West","page":"Basic Interface","title":"MenuAdventures.West","text":"West()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#Relationships","page":"Basic Interface","title":"Relationships","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"Carrying\nContaining","category":"page"},{"location":"#MenuAdventures.Carrying","page":"Basic Interface","title":"MenuAdventures.Carrying","text":"Carrying()\n\nA is carrying B means B is carried by A.\n\nA Relationship.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Containing","page":"Basic Interface","title":"MenuAdventures.Containing","text":"Containing()\n\nA is containing B means B is in A.\n\nA Relationship.\n\n\n\n\n\n","category":"type"},{"location":"#Domains","page":"Basic Interface","title":"Domains","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"ExitDirections\nImmediate\nInventory\nReachable\nVisible","category":"page"},{"location":"#MenuAdventures.ExitDirections","page":"Basic Interface","title":"MenuAdventures.ExitDirections","text":"ExitDirections()\n\nDirections that a player, or the vehicle a player is in, might exit in.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Immediate","page":"Basic Interface","title":"MenuAdventures.Immediate","text":"Immediate()\n\nThing that are in/on the same place the player could move from.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Inventory","page":"Basic Interface","title":"MenuAdventures.Inventory","text":"Inventory()\n\nThings the player is carrying.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Reachable","page":"Basic Interface","title":"MenuAdventures.Reachable","text":"Reachable()\n\nAnything the player can reach.\n\nA Domain. Players can't reach through closed containers by default.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Visible","page":"Basic Interface","title":"MenuAdventures.Visible","text":"Visible()\n\nAnything the player can see.\n\nA Domain. By default, players can't see into closed, opaque containers.\n\n\n\n\n\n","category":"type"},{"location":"#Actions","page":"Basic Interface","title":"Actions","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"Action\nDrop\nGo\nGoInto\nLeave\nListInventory\nLookAt\nOpenOrClose\nPutInto\nTake\nQuit\nUnlockOrLock","category":"page"},{"location":"#MenuAdventures.Action","page":"Basic Interface","title":"MenuAdventures.Action","text":"abstract type Action end\n\nAn Action the player can take.\n\nTo create a new action, you will need to add methods for\n\nMenuAdventures.ever_possible for abstract possibilities\nMenuAdventures.possible_now for concrete possibilities\nMenuAdventures.argument_domains to specify the domain of the arguments\nMenuAdventures.print_sentence for printing the sentence\nMenuAdventures.mention_status for mentioning the status of a thing.\n\nNote that the order arguments are printed in need not match the order they are listed. However, the order of arguments for MenuAdventures.argument_domains must match the order of arguments for MenuAdventures.print_sentence.\n\nMost importantly, define:\n\nfunction (::MyNewAction)(universe, arguments...) -> Bool\n\nwhich will conduct the action based on user choices.  Return true to end the game, or false to continue onto the next turn. You can overload Action calls for a Noun subtype. Use Base.invoke to avoid replicating the Action machinery.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Drop","page":"Basic Interface","title":"MenuAdventures.Drop","text":"Drop()\n\nDrop something in your Inventory.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Go","page":"Basic Interface","title":"MenuAdventures.Go","text":"Go()\n\nGo in one of ExitDirections.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.GoInto","page":"Basic Interface","title":"MenuAdventures.GoInto","text":"GoInto()\n\nGo into something Immediate.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Leave","page":"Basic Interface","title":"MenuAdventures.Leave","text":"Leave()\n\nLeave whatever the player is in/on.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.ListInventory","page":"Basic Interface","title":"MenuAdventures.ListInventory","text":"ListInventory()\n\nList the player's inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.LookAt","page":"Basic Interface","title":"MenuAdventures.LookAt","text":"LookAt()\n\nLook at something Visible.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.OpenOrClose","page":"Basic Interface","title":"MenuAdventures.OpenOrClose","text":"OpenOrClose()\n\nOpen or close something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.PutInto","page":"Basic Interface","title":"MenuAdventures.PutInto","text":"PutInto()\n\nPut something from your Inventory into something Reachable.\n\nAn Action. By default,\n\never_possible(::PutInto, ::Inventory, anything) = true\n\nthat is, it is always possible to put something from your inventory into a container, and\n\never_possible(::PutInto, ::Reachable, ::AbstractRoom) = true\n\nthat is, all rooms act like containers.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Take","page":"Basic Interface","title":"MenuAdventures.Take","text":"Take()\n\nTake something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Quit","page":"Basic Interface","title":"MenuAdventures.Quit","text":"Quit()\n\nQuit\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.UnlockOrLock","page":"Basic Interface","title":"MenuAdventures.UnlockOrLock","text":"UnlockOrLock()\n\nUnlock or lock something Reachable with something from your Inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#Miscellaneous","page":"Basic Interface","title":"Miscellaneous","text":"","category":"section"},{"location":"","page":"Basic Interface","title":"Basic Interface","text":"first_person\nsecond_person\nthird_person\nstring_in_color\nsubject_to_verb\nVerb\nget_children_relationships\nget_parent_relationship\nget_exit_directions","category":"page"},{"location":"#MenuAdventures.first_person","page":"Basic Interface","title":"MenuAdventures.first_person","text":"first_person\n\nFirst person (e.g. I).\n\nIn games, the narrator is typically the first person.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.second_person","page":"Basic Interface","title":"MenuAdventures.second_person","text":"second_person\n\nSecond person (e.g. you).\n\nIn games, the player is typically the second person.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.third_person","page":"Basic Interface","title":"MenuAdventures.third_person","text":"third_person\n\nThird person (e.g. he, she, it).\n\nIn games, everything is typically third person except for the player and narrator.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.string_in_color","page":"Basic Interface","title":"MenuAdventures.string_in_color","text":"string_in_color(color::Symbol, arguments...)\n\nUse ASCII escape codes to add a color to the arguments collected as a string.\n\n\n\n\n\n","category":"function"},{"location":"#MenuAdventures.subject_to_verb","page":"Basic Interface","title":"MenuAdventures.subject_to_verb","text":"subject_to_verb(subject, verb)\n\nFind the Verb form to agree with a subject.\n\n\n\n\n\n","category":"function"},{"location":"#MenuAdventures.Verb","page":"Basic Interface","title":"MenuAdventures.Verb","text":"Verb(base; third_person_singular_present = string(base, \"s\"))\n\nCreate an English verb.\n\nUse subject_to_verb to get the form of a verb to agree with a subject. Unexported verbs include MenuAdventures.DO and MenuAdventures.BE.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.get_children_relationships","page":"Basic Interface","title":"MenuAdventures.get_children_relationships","text":"get_children_relationships(universe, parent_thing)\n\nGet the children of parent_thing in the universe, and the Relationships of parent_thing to them.\n\n\n\n\n\n","category":"function"},{"location":"#MenuAdventures.get_parent_relationship","page":"Basic Interface","title":"MenuAdventures.get_parent_relationship","text":"get_parent_relationship(universe, thing)\n\nGet the parent of a thing in the universe, and the parent's Relationship to it.\n\n\n\n\n\n","category":"function"},{"location":"#MenuAdventures.get_exit_directions","page":"Basic Interface","title":"MenuAdventures.get_exit_directions","text":"get_exit_directions(universe, location)\n\nGet the exits from a location, and the direction of those exits.\n\n\n\n\n\n","category":"function"},{"location":"ExtraDirections/#ExtraDirections","page":"ExtraDirections extension","title":"ExtraDirections","text":"","category":"section"},{"location":"ExtraDirections/","page":"ExtraDirections extension","title":"ExtraDirections extension","text":"Pages = [\"ExtraDirections.md\"]","category":"page"},{"location":"ExtraDirections/","page":"ExtraDirections extension","title":"ExtraDirections extension","text":"Modules = [MenuAdventures.ExtraDirections]","category":"page"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections","text":"MenuAdventures.ExtraDirections\n\nA sub-module with a bunch of extra directions\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.ExtraDirections\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"ExtraDirections\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                center_room = Room(\"central room\")\n                universe = Universe(you, interface = interface)\n                universe[center_room, you] = Containing()\n                universe[center_room, Room(\"room\")] = West()\n                universe[center_room, Room(\"room\")] = NorthWest()\n                universe[center_room, Room(\"room\")] = North()\n                universe[center_room, Room(\"room\")] = NorthEast()\n                universe[center_room, Room(\"room\")] = East()\n                universe[center_room, Room(\"room\")] = SouthEast()\n                universe[center_room, Room(\"room\")] = South()\n                universe[center_room, Room(\"room\")] = SouthWest()\n                universe[center_room, Room(\"room\")] = Up()\n                universe[center_room, Room(\"room\")] = Down()\n                universe[center_room, Room(\"room\")] = Inside()\n                universe[center_room, Room(\"room\")] = Outside()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Down","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.Down","text":"Down()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Inside","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.Inside","text":"Inside()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.NorthEast","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.NorthEast","text":"NorthEast()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.NorthWest","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.NorthWest","text":"NorthWest()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Outside","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.Outside","text":"Outside()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.SouthEast","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.SouthEast","text":"SouthEast()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.SouthWest","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.SouthWest","text":"SouthWest()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Up","page":"ExtraDirections extension","title":"MenuAdventures.ExtraDirections.Up","text":"Up()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [MenuAdventures]\nPublic = false","category":"page"},{"location":"internals/#MenuAdventures.argument_domains","page":"Internals","title":"MenuAdventures.argument_domains","text":"argument_domains(action::Action)\n\nReturn a tuple of the Domains for each argument of an Action.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.blocking","page":"Internals","title":"MenuAdventures.blocking","text":"MenuAdventures.blocking(domain, parent_thing, relationship, thing)\n\nparent_thing is blocked from accessing thing via the relationship.\n\nBy default, Reachable parent_things block things they are containing if they are closed. By default, Visible parent_things block things they are containing if they are closed and not MenuAdventures.is_transparent.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.ever_possible-Tuple{Any,Any,Any}","page":"Internals","title":"MenuAdventures.ever_possible","text":"MenuAdventures.ever_possible(action::Action, domain::Domain, noun::Noun)\n\nWhether it is abstractly possible to apply an Action to a Noun from a particular Domain.\n\nFor whether it is concretely possible for the player in at a certain moment, see possible_now. Most possibilities default to false, with some exceptions, documented in specific actions.\n\nCertain possibilities come with required fields:\n\never_possible(::Open, ::Reachable, noun requires that noun has a mutable closed::Bool field.\never_possible(::Unlock, ::Reachable, noun) requires that noun has a key::Noun field and a mutable locked::Bool field.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.find_in_domain","page":"Internals","title":"MenuAdventures.find_in_domain","text":"MenuAdventures.find_in_domain(universe, sentence, domain; lit = true)\n\nReturn a vector of Answers for all things around the player in a certain Domain.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.indefinite-Tuple{Any}","page":"Internals","title":"MenuAdventures.indefinite","text":"MenuAdventures.indefinite(domain) = \"something\"\n\nPlaceholder for an object from the Domain.\n\nFor example, the indefinite for ExitDirections is \"some way\".\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.interrogative-Tuple{Any}","page":"Internals","title":"MenuAdventures.interrogative","text":"MenuAdventures.interrogative(domain) = \"something\"\n\nAsk for an object from the Domain.\n\nFor example, the interrogative for ExitDirections is \"which way\".\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_shining-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_shining","text":"is_shining(::Noun) = false\n\nWhether something provides its own light.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_transparent-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_transparent","text":"MenuAdventures.is_transparent(thing::Noun) = false\n\nWhether you can see through thing into its contents.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_vehicle-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_vehicle","text":"MenuAdventures.is_vehicle(::Noun) = false\n\nWhether something is a vehicle.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.look_around-NTuple{4,Any}","page":"Internals","title":"MenuAdventures.look_around","text":"MenuAdventures.look_around(universe, domain, blocking_thing, blocked_relationship)\n\nLook around a lit location.\n\nYou can overload look_around for a Noun subtype. Use Base.invoke to avoid replicating the look_around machinery.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.mention_status-Tuple{Any,Any,Any}","page":"Internals","title":"MenuAdventures.mention_status","text":"mention_status(io, action, thing)\n\nPrint the status of thing corresponding to action into io.\n\nFor example, for the OpenOrClose action, will display whether thing is open or closed. Called for all action subtypes when mentioning a thing. Defaults to doing nothing.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.opposite","page":"Internals","title":"MenuAdventures.opposite","text":"MenuAdventures.opposite(direction::Direction)\n\nThe opposite of a Direction.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.possible_now-NTuple{4,Any}","page":"Internals","title":"MenuAdventures.possible_now","text":"MenuAdventures.possible_now(universe, sentence, domain, thing)\n\nWhether it is currently possible to apply sentence.action to a thing in a domain.\n\nSee ever_possible for a more abstract possibilities.  sentence will contain already chosen arguments, should you wish to access them.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.possible_now-Tuple{Any,Any}","page":"Internals","title":"MenuAdventures.possible_now","text":"possible_now(universe, action)\n\nWhether it is possible to conduct an action. Defaults to true; you can set to false for some actions without arguments.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.print_sentence","page":"Internals","title":"MenuAdventures.print_sentence","text":"MenuAdventures.print_sentence(io, action::Action, argument_answers::Answer...)\n\nPrint a sentence to io.\n\nThis allows for inserting connectives like with. Arguments will be passed as Answers.\n\n\n\n\n\n","category":"function"}]
}
