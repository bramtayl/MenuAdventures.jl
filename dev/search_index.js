var documenterSearchIndex = {"docs":
[{"location":"Outfits/#Outfits","page":"Outfits","title":"Outfits","text":"","category":"section"},{"location":"Outfits/","page":"Outfits","title":"Outfits","text":"Pages = [\"Outfits.md\"]","category":"page"},{"location":"Outfits/","page":"Outfits","title":"Outfits","text":"Modules = [MenuAdventures.Outfits]","category":"page"},{"location":"Outfits/#MenuAdventures.Outfits","page":"Outfits","title":"MenuAdventures.Outfits","text":"MenuAdventures.Outfits\n\nA sub-module with the wearing relationship.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Outfits\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Clothes <: Noun\n        end;\n\njulia> ever_possible(::Dress, ::Inventory, ::Clothes) = true;\n\njulia> ever_possible(::Take, ::Reachable, ::Clothes) = true;\n\njulia> ever_possible(::Dress, ::Reachable, ::Person) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Outfits\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                coat = Clothes(\"coat\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, Clothes(\"coat\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Outfits/#MenuAdventures.Outfits.Dress","page":"Outfits","title":"MenuAdventures.Outfits.Dress","text":"Dress()\n\nDress someone Reachable in something from your Inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Outfits/#MenuAdventures.Outfits.Wearing","page":"Outfits","title":"MenuAdventures.Outfits.Wearing","text":"Wearing()\n\nA is Wearing B means B is worn by A.\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"Talking/#Talking","page":"Talking","title":"Talking","text":"","category":"section"},{"location":"Talking/","page":"Talking","title":"Talking","text":"Pages = [\"Talking.md\"]","category":"page"},{"location":"Talking/","page":"Talking","title":"Talking","text":"Modules = [MenuAdventures.Talking]","category":"page"},{"location":"Talking/#MenuAdventures.Talking","page":"Talking","title":"MenuAdventures.Talking","text":"MenuAdventures.Talking\n\nA sub-module with the Dialog domain.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Talking\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct NPC <: Noun\n            dialog::Dict{String, Answer} = Dict{String, Answer}()\n        end;\n\njulia> ever_possible(::Say, ::Visible, ::NPC) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Talking\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                friend = NPC(\n                    \"your friend\",\n                    indefinite_article = \"\",\n                    dialog = Dict(\"Hello\" => Answer(\"Hello\", (universe, person) -> nothing))\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, friend] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Talking/#MenuAdventures.Talking.Dialog","page":"Talking","title":"MenuAdventures.Talking.Dialog","text":"Dialog()\n\nThings a player might say.\n\nFor dialog, the keys will be things you can say, and answers will be replies.\n\nThe text of answer objects will be the quoted version of their object.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"Talking/#MenuAdventures.Talking.Say","page":"Talking","title":"MenuAdventures.Talking.Say","text":"Say()\n\nSay, to someone Visible, some Dialog.\n\nAn Action.  Note the first argument is the addressee, and the second is the dialog. If possible(::Say, ::Dialog, addressee), then addressee must have a dialog field containing a dialog dictionary. The keys of this dictionary should be text the player says, and the values should be [Answer]s containing a response from the addressee and a trigger. After a dialog option is chosen, the response trigger will be called with two arguments: universe and addressee. Then the dialog option will be removed.\n\n\n\n\n\n","category":"type"},{"location":"Parts/#Parts","page":"Parts","title":"Parts","text":"","category":"section"},{"location":"Parts/","page":"Parts","title":"Parts","text":"Pages = [\"Parts.md\"]","category":"page"},{"location":"Parts/","page":"Parts","title":"Parts","text":"Modules = [MenuAdventures.Parts]","category":"page"},{"location":"Parts/#MenuAdventures.Parts","page":"Parts","title":"MenuAdventures.Parts","text":"MenuAdventures.Parts\n\nA sub-module with the incorporating relationship.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Parts\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct StickyThing <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::StickyThing) = true;\n\njulia> ever_possible(::Attach, ::Inventory, ::StickyThing) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Parts\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, StickyThing(\"sticky thing\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Parts/#MenuAdventures.Parts.Attach","page":"Parts","title":"MenuAdventures.Parts.Attach","text":"Attach()\n\nAttach something from your Inventory to something else Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Parts/#MenuAdventures.Parts.Incorporating","page":"Parts","title":"MenuAdventures.Parts.Incorporating","text":"Incorporating()\n\nA is Incorporating B means B is part of A\"\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"Testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"Testing/","page":"Testing","title":"Testing","text":"Pages = [\"Testing.md\"]","category":"page"},{"location":"Testing/","page":"Testing","title":"Testing","text":"Modules = [MenuAdventures.Testing]","category":"page"},{"location":"Testing/#MenuAdventures.Testing.check_choices-Tuple{Any}","page":"Testing","title":"MenuAdventures.Testing.check_choices","text":"check_choices(make_universe;\n    choices_file = \"choices.txt\", \n    transcript_file = \"transcript.txt\"\n)\n\nCheck the results of choices against a transcript created with save_choices.\n\nReturn true if the results match, false otherwise. make_universe should be a function which takes one argument, an IO interface, and returns an [AbstractUniverse]. choices_file will be the delimited file where user choices were saved. transcript_file will be the file where the game transcript was saved.\n\n\n\n\n\n","category":"method"},{"location":"Testing/#MenuAdventures.Testing.save_choices-Tuple{Any}","page":"Testing","title":"MenuAdventures.Testing.save_choices","text":"save_choices(make_universe;\n    choices_file = \"choices.txt\", \n    transcript_file = \"transcript.txt\",\n    resume = false\n)\n\nSave the choices a user makes as a delimited file, as well as the transcript of the game.\n\nUse to create a transcript to test with check_choices. make_universe should be a function which takes one argument, an IO interface, and returns an [AbstractUniverse]. choices_file will be the delimited file where user choices are saved. transcript_file will be the file where the game transcript will be saved. If resume is true, the game will pick up from the point you left off, based on the existing choices_file.\n\n\n\n\n\n","category":"method"},{"location":"ExtraVerbs/#ExtraVerbs","page":"ExtraVerbs","title":"ExtraVerbs","text":"","category":"section"},{"location":"ExtraVerbs/","page":"ExtraVerbs","title":"ExtraVerbs","text":"Pages = [\"ExtraVerbs.md\"]","category":"page"},{"location":"ExtraVerbs/","page":"ExtraVerbs","title":"ExtraVerbs","text":"Modules = [MenuAdventures.ExtraVerbs]","category":"page"},{"location":"ExtraVerbs/#MenuAdventures.ExtraVerbs","page":"ExtraVerbs","title":"MenuAdventures.ExtraVerbs","text":"MenuAdventures.ExtraVerbs\n\nA sub-module with the incorporating relationship.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.ExtraVerbs\n\njulia> import MenuAdventures: ever_possible, is_shining\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Food <: Noun\n        end;\n\njulia> ever_possible(::Eat, ::Reachable, ::Food) = true;\n\njulia> @noun mutable struct Lamp <: Noun\n            on::Bool = false\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Lamp) = true;\n\njulia> ever_possible(::TurnOnOrOff, ::Reachable, ::Lamp) = true;\n\njulia> is_shining(thing::Lamp) = thing.on;\n\njulia> @noun struct Anvil <: Noun\n        end;\n\njulia> ever_possible(::PushBetweenRooms, ::Immediate, ::Anvil) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"ExtraVerbs\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                light_room = Room(\"light room\")\n                dark_room = Room(\"dark room\", already_lit = false)\n                universe = Universe(you, interface = interface)\n                universe[light_room, dark_room] = North()\n                universe[light_room, you] = Containing()\n                universe[light_room, Lamp(\"lamp\")] = Containing()\n                universe[light_room, Food(\"food\")] = Containing()\n                universe[light_room, Anvil(\"anvil\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"ExtraVerbs/#MenuAdventures.ExtraVerbs.Eat","page":"ExtraVerbs","title":"MenuAdventures.ExtraVerbs.Eat","text":"Eat()\n\nEat something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"ExtraVerbs/#MenuAdventures.ExtraVerbs.Give","page":"ExtraVerbs","title":"MenuAdventures.ExtraVerbs.Give","text":"Give()\n\nGive something from your Inventory to someone Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"ExtraVerbs/#MenuAdventures.ExtraVerbs.PushBetweenRooms","page":"ExtraVerbs","title":"MenuAdventures.ExtraVerbs.PushBetweenRooms","text":"PushBetweenRooms()\n\nPushBetweenRooms something Immediate in one of ExitDirections.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"ExtraVerbs/#MenuAdventures.ExtraVerbs.TurnOnOrOff","page":"ExtraVerbs","title":"MenuAdventures.ExtraVerbs.TurnOnOrOff","text":"TurnOnOrOff()\n\nTurn on or off something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Onto/#Onto","page":"Onto","title":"Onto","text":"","category":"section"},{"location":"Onto/","page":"Onto","title":"Onto","text":"Pages = [\"Onto.md\"]","category":"page"},{"location":"Onto/","page":"Onto","title":"Onto","text":"Modules = [MenuAdventures.Onto]","category":"page"},{"location":"Onto/#MenuAdventures.Onto","page":"Onto","title":"MenuAdventures.Onto","text":"MenuAdventures.Onto\n\nA sub-module with the supporting relationship.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.Onto\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Thing <: Noun\n        end;\n\njulia> @noun struct Table <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Thing) = true;\n\njulia> ever_possible(::PutOnto, ::Reachable, ::Table) = true;\n\njulia> ever_possible(::GoOnto, ::Immediate, ::Table) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"Onto\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                room = Room(\"room\")\n                universe = Universe(you, interface = interface)\n                universe[room, you] = Containing()\n                universe[room, Table(\"table\")] = Containing()\n                universe[room, Thing(\"thing\")] = Containing()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"Onto/#MenuAdventures.Onto.GoOnto","page":"Onto","title":"MenuAdventures.Onto.GoOnto","text":"GoOnto()\n\nGo onto something Immediate.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"Onto/#MenuAdventures.Onto.PutOnto","page":"Onto","title":"MenuAdventures.Onto.PutOnto","text":"PutOnto()\n\nPut something from your Inventory onto something Reachable.\n\nAn Action. By default, ever_possible(::PutOnto, ::Inventory, _) = true, that is, you can always put something from your inventory onto a surface.\n\n\n\n\n\n","category":"type"},{"location":"Onto/#MenuAdventures.Onto.Supporting","page":"Onto","title":"MenuAdventures.Onto.Supporting","text":"Supporting()\n\nA is Supporting B means B is on top of A.\n\nA Relationship\n\n\n\n\n\n","category":"type"},{"location":"#Exports","page":"Exports","title":"Exports","text":"","category":"section"},{"location":"","page":"Exports","title":"Exports","text":"Pages = [\"index.md\"]","category":"page"},{"location":"","page":"Exports","title":"Exports","text":"Modules = [MenuAdventures]\nPrivate = false","category":"page"},{"location":"#MenuAdventures.MenuAdventures","page":"Exports","title":"MenuAdventures.MenuAdventures","text":"MenuAdventures\n\nA module for creating text adventures based on Menus.\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> import MenuAdventures: ever_possible\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> @noun struct Key <: Noun\n        end;\n\njulia> ever_possible(::Take, ::Reachable, ::Key) = true;\n\njulia> ever_possible(::UnlockOrLock, ::Inventory, ::Key) = true;\n\njulia> @noun mutable struct LockableDoor <: AbstractDoor\n            key::Noun\n            closed::Bool = true\n            locked::Bool = true\n        end;\n\njulia> ever_possible(::OpenOrClose, ::Reachable, ::LockableDoor) = true;\n\njulia> ever_possible(::UnlockOrLock, ::Reachable, ::LockableDoor) = true;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    description = (universe, self) -> \"What a dork!\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                entrance = Room(\n                    \"the entrance\",\n                    description = (universe, self) -> \"The entrance to the castle\",\n                    indefinite_article = \"\"\n                )\n                castle = Room(\n                    \"the castle\", \n                    description = (universe, self) -> \"What kind of castle only has one room!\", \n                    indefinite_article = \"\"\n                )\n                old_key = Key(\n                    \"old key\",\n                    description = (universe, self) -> \"It looks old?\",\n                    indefinite_article = \"an\"\n                )\n                big_door = LockableDoor(\n                    \"big door\",\n                    old_key,\n                    description = (universe, self) -> \"It looks big?\",\n                )\n                universe = Universe(\n                    you,\n                    introduction = \"Welcome!\",\n                    interface = interface\n                )\n                universe[entrance, you] = Containing()\n                universe[entrance, old_key] = Containing()\n                universe[entrance, castle] = big_door, West()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"#MenuAdventures.first_person","page":"Exports","title":"MenuAdventures.first_person","text":"first_person\n\nFirst person (e.g. I).\n\nIn games, the narrator is typically the first person.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.second_person","page":"Exports","title":"MenuAdventures.second_person","text":"second_person\n\nSecond person (e.g. you).\n\nIn games, the player is typically the second person.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.third_person","page":"Exports","title":"MenuAdventures.third_person","text":"third_person\n\nThird person (e.g. he, she, it).\n\nIn games, everything is typically third person except for the player and narrator.\n\n\n\n\n\n","category":"constant"},{"location":"#MenuAdventures.AbstractDoor","page":"Exports","title":"MenuAdventures.AbstractDoor","text":"abstract type AbstractDoor <: Location end\n\nAn abstract door\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.AbstractRoom","page":"Exports","title":"MenuAdventures.AbstractRoom","text":"abstract type AbstractRoom <: Location end\n\nAn abstract room.\n\nYou must include a already_lit::Bool field.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.AbstractUniverse","page":"Exports","title":"MenuAdventures.AbstractUniverse","text":"abstract type AbstractUniverse end\n\nContains all the information about the game universe.\n\nYou will need to create your own AbstractUniverse subtype. See [@universe] for an easy way to do this.\n\nThe universe is organized as interlinking web of Locations connected by Directions. Each location is the root of a tree of Nouns connected by Relationships.\n\nYou can add a new thing to the universe, or change the location of something, by specifying its relation to another thing:\n\nuniverse[parent_thing, thing] = relationship\n\nYou can add a connection between locations too, optionally interspersed by a door:\n\nuniverse[parent_thing, destination, one_way = false] = direction\nuniverse[parent_thing, destination, one_way = false] = door, direction\n\nBy default, this will create a way back in the MenuAdventures.opposite direction. To suppress this, set one_way = true\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Action","page":"Exports","title":"MenuAdventures.Action","text":"abstract type Action end\n\nA action is an action the player can take.\n\nTo create a new action, you will need to add methods for\n\nMenuAdventures.ever_possible for abstract possibilities\nMenuAdventures.possible_now for concrete possibilities\nMenuAdventures.argument_domains to specify the domain of the arguments\nMenuAdventures.print_sentence for printing the sentence\nMenuAdventures.mention_status for mentioning the status of a thing.\n\nNote that the order arguments are printed in need not match the order they are listed. However, the order of arguments for MenuAdventures.argument_domains must match the order of arguments for MenuAdventures.print_sentence.\n\nMost importantly, define:\n\nfunction (::MyNewAction)(universe, arguments...) -> Bool\n\nWhich will conduct the action based on user choices.  Return true to end the game, otherwise, continue onto the next turn. You can overload Action calls for a Noun subtype. Use Base.invoke to avoid replicating the Action machinery.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Answer","page":"Exports","title":"MenuAdventures.Answer","text":"Answer(text::String, object::Any)\n\nAn answer has two fields: text, which will be how the option is displayed in a menu, and object.\n\nobject might be a noun, direction, trigger, or even a question.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Carrying","page":"Exports","title":"MenuAdventures.Carrying","text":"Carrying()\n\nA is carrying B means B is carried by A.\n\nA Relationship.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Containing","page":"Exports","title":"MenuAdventures.Containing","text":"Containing()\n\nA is containing B means B is in A.\n\nA Relationship.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Direction","page":"Exports","title":"MenuAdventures.Direction","text":"abstract type Direction end\n\nDirections show the relationships between Locations.\n\nFor example, a place can be North of another place. To create a new Direction, you must add a method for\n\nshow\nthe MenuAdventures.opposite of the direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Domain","page":"Exports","title":"MenuAdventures.Domain","text":"abstract type Domain end\n\nA domain refers to a search space for a specific argument to an Action.\n\nDomains serve both as a way of distinguishing different arguments to an action, and also, categorizing the environment around the player. For example, you are only able to look at things in the Visible domain. To create a new domain, you must add a method for:\n\nMenuAdventures.find_in_domain\nMenuAdventures.indefinite\nMenuAdventures.interrogative\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Drop","page":"Exports","title":"MenuAdventures.Drop","text":"Drop()\n\nDrop something in your Inventory.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.East","page":"Exports","title":"MenuAdventures.East","text":"East()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.ExitDirections","page":"Exports","title":"MenuAdventures.ExitDirections","text":"ExitDirections()\n\nDirections that a player, or the vehicle a player is in, might exit in.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Go","page":"Exports","title":"MenuAdventures.Go","text":"Go()\n\nGo in one of ExitDirections.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.GoInto","page":"Exports","title":"MenuAdventures.GoInto","text":"GoInto()\n\nGo into something Immediate.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Immediate","page":"Exports","title":"MenuAdventures.Immediate","text":"Immediate()\n\nThing that are in/on the same place the player could more from.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Inventory","page":"Exports","title":"MenuAdventures.Inventory","text":"Inventory()\n\nThings the player is carrying.\n\nA Domain.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Leave","page":"Exports","title":"MenuAdventures.Leave","text":"Leave()\n\nLeave whatever the player is in/on.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.ListInventory","page":"Exports","title":"MenuAdventures.ListInventory","text":"ListInventory()\n\nList the player's inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Location","page":"Exports","title":"MenuAdventures.Location","text":"abstract type Location <: Noun end\n\nA location (room or door)\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.LookAt","page":"Exports","title":"MenuAdventures.LookAt","text":"LookAt()\n\nLook at something Visible.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.North","page":"Exports","title":"MenuAdventures.North","text":"North()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Noun","page":"Exports","title":"MenuAdventures.Noun","text":"abstract type Noun end\n\nYou must make your own custom Noun subtypes for almost everything in your game. \n\nSee @noun for information about required fields. Nouns are additionally characterized by the following traits and methods:\n\nMenuAdventures.ever_possible\nMenuAdventures.is_shining\nMenuAdventures.is_transparent\nMenuAdventures.is_vehicle\n\nThe following IOContext components will be respected when showing nouns:\n\n:capitalize::Bool => false\n:known::Bool => true, set to false to include the indefinite article if it exists.\n:is_subject => true, whether the noun is the subject of the sentence. If this is set to false, you must also include\n:subject::Noun, the subject of the sentence.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.OpenOrClose","page":"Exports","title":"MenuAdventures.OpenOrClose","text":"OpenOrClose()\n\nOpen or close something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.PutInto","page":"Exports","title":"MenuAdventures.PutInto","text":"PutInto()\n\nPut something from your Inventory into something Reachable.\n\nAn Action. By default,\n\never_possible(::PutInto, ::Inventory, _) = true\n\nthat is, it is always possible to put something from your inventory into a container, and\n\never_possible(::PutInto, ::Reachable, ::AbstractRoom) = true\n\nthat is, all rooms act like containers.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Quit","page":"Exports","title":"MenuAdventures.Quit","text":"Quit()\n\nQuit\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Reachable","page":"Exports","title":"MenuAdventures.Reachable","text":"Reachable()\n\nAnything the player can reach.\n\nA Domain. Players can't reach through closed containers by default.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Relationship","page":"Exports","title":"MenuAdventures.Relationship","text":"abstract type Relationship end\n\nRelationships show the relationships between Nouns. \n\nFor example, something can be Containing something else.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Sentence-Tuple{Action}","page":"Exports","title":"MenuAdventures.Sentence","text":"Sentence(action::Action; argument_answers = Answer[])\n\nA sentence has two fields: action, the Action to be taken, and argument_answers, the arguments to the action. \n\nArguments will be returned as Answers. The subject is implicitly universe.player.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.South","page":"Exports","title":"MenuAdventures.South","text":"South()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Take","page":"Exports","title":"MenuAdventures.Take","text":"Take()\n\nTake something Reachable.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.UnlockOrLock","page":"Exports","title":"MenuAdventures.UnlockOrLock","text":"UnlockOrLock()\n\nUnlock or lock something Reachable with something from your Inventory.\n\nAn Action.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.Verb-Tuple{Any}","page":"Exports","title":"MenuAdventures.Verb","text":"Verb(base; third_person_singular_present = string(base, \"s\"))\n\nCreate an English verb.\n\nUse subject_to_verb to get the form of a verb to agree with a subject. Unexported verbs include MenuAdventures.DO and MenuAdventures.BE.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.Visible","page":"Exports","title":"MenuAdventures.Visible","text":"Visible()\n\nAnything the player can see.\n\nA Domain. By default, players can't see into closed, opaque containers.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.West","page":"Exports","title":"MenuAdventures.West","text":"West()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"#MenuAdventures.get_children_relationships-Tuple{Any,Any}","page":"Exports","title":"MenuAdventures.get_children_relationships","text":"get_children_relationships(universe, parent_thing)\n\nGet the children of parent_thing in the universe, and the Relationships of parent_thing to them.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.get_exit_directions-Tuple{Any,Any}","page":"Exports","title":"MenuAdventures.get_exit_directions","text":"get_exit_directions(universe, location)\n\nGet the exits from a location, and the direction of those exits.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.get_parent_relationship-Tuple{Any,Any}","page":"Exports","title":"MenuAdventures.get_parent_relationship","text":"get_parent_relationship(universe, thing)\n\nGet the parent of a thing in the universe, and the parent's Relationship to it.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.string_in_color-Tuple{Symbol,Vararg{Any,N} where N}","page":"Exports","title":"MenuAdventures.string_in_color","text":"string_in_color(color::Symbol, arguments...)\n\nUse ASCII escape codes add a color to the arguments collected as a string.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.subject_to_verb-Tuple{Any,Any}","page":"Exports","title":"MenuAdventures.subject_to_verb","text":"subject_to_verb(subject, verb)\n\nFind the Verb form to agree with a subject.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.turn!-Tuple{Any}","page":"Exports","title":"MenuAdventures.turn!","text":"turn!(universe; introduce = true)\n\nStart a turn in the AbstractUniverse, and keep going until an Action returns true.\n\nYou can overload turn! for an AbstractUniverse. Use Base.invoke to avoid replicating the turn! machinery.\n\n\n\n\n\n","category":"method"},{"location":"#MenuAdventures.@noun-Tuple{Any}","page":"Exports","title":"MenuAdventures.@noun","text":"@noun user_definition\n\nAutomatically add the required fields to a Noun struct definition, including sane defaults.\n\nAdds the following fields and defaults:\n\nname::String\nplural::Bool = false\ngrammatical_person::GrammaticalPerson = third_person, see third_person\nindefinite_article::String = \"a\"\ndescription = (_, __) -> \"\"\n\nSet indefinite_article to \"\" for proper nouns. description should be a function which takes two arguments, the universe and the thing itself, and returns a description.\n\n\n\n\n\n","category":"macro"},{"location":"#MenuAdventures.@universe-Tuple{Any}","page":"Exports","title":"MenuAdventures.@universe","text":"@universe user_definition\n\nAutomatically add the required fields to an [AbstractUniverse] struct definition, including sane defaults.\n\nAdds the following fields and defaults:\n\nplayer::Noun. The player will typically be the second_person.\ninterface::TTYTerminal = terminal\nintroduction::String = \"\"\nrelationships_graph = MetaGraph(DiGraph(), Label = Noun, EdgeMeta = Relationship)), the Relationships between Nouns.\ndirections_graph = MetaGraph(DiGraph(), Label = Location, EdgeMeta = Direction)), the Directions between Locations.\nchoices_log::Vector{Int} = Int[] saves all choices the user makes\n\nSee AbstractUniverse for more information.\n\n\n\n\n\n","category":"macro"},{"location":"ExtraDirections/#ExtraDirections","page":"ExtraDirections","title":"ExtraDirections","text":"","category":"section"},{"location":"ExtraDirections/","page":"ExtraDirections","title":"ExtraDirections","text":"Pages = [\"ExtraDirections.md\"]","category":"page"},{"location":"ExtraDirections/","page":"ExtraDirections","title":"ExtraDirections","text":"Modules = [MenuAdventures.ExtraDirections]","category":"page"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections","text":"MenuAdventures.ExtraDirections\n\nA sub-module with a bunch of extra directions\n\njulia> using MenuAdventures\n\njulia> using MenuAdventures.Testing\n\njulia> using MenuAdventures.ExtraDirections\n\njulia> @universe struct Universe <: AbstractUniverse\n        end;\n\njulia> @noun struct Room <: AbstractRoom\n            already_lit::Bool = true\n        end;\n\njulia> @noun struct Person <: Noun\n        end;\n\njulia> cd(joinpath(pkgdir(MenuAdventures), \"test\", \"ExtraDirections\")) do\n            check_choices() do interface\n                you = Person(\n                    \"Brandon\",\n                    grammatical_person = second_person,\n                    indefinite_article = \"\",\n                )\n                center_room = Room(\"central room\")\n                universe = Universe(you, interface = interface)\n                universe[center_room, you] = Containing()\n                universe[center_room, Room(\"room\")] = West()\n                universe[center_room, Room(\"room\")] = NorthWest()\n                universe[center_room, Room(\"room\")] = North()\n                universe[center_room, Room(\"room\")] = NorthEast()\n                universe[center_room, Room(\"room\")] = East()\n                universe[center_room, Room(\"room\")] = SouthEast()\n                universe[center_room, Room(\"room\")] = South()\n                universe[center_room, Room(\"room\")] = SouthWest()\n                universe[center_room, Room(\"room\")] = Up()\n                universe[center_room, Room(\"room\")] = Down()\n                universe[center_room, Room(\"room\")] = Inside()\n                universe[center_room, Room(\"room\")] = Outside()\n                universe\n            end\n        end\ntrue\n\n\n\n\n\n","category":"module"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Down","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.Down","text":"Down()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Inside","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.Inside","text":"Inside()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.NorthEast","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.NorthEast","text":"NorthEast()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.NorthWest","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.NorthWest","text":"NorthWest()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Outside","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.Outside","text":"Outside()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.SouthEast","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.SouthEast","text":"SouthEast()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.SouthWest","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.SouthWest","text":"SouthWest()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"ExtraDirections/#MenuAdventures.ExtraDirections.Up","page":"ExtraDirections","title":"MenuAdventures.ExtraDirections.Up","text":"Up()\n\nA Direction.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [MenuAdventures]\nPublic = false","category":"page"},{"location":"internals/#MenuAdventures.argument_domains","page":"Internals","title":"MenuAdventures.argument_domains","text":"argument_domains(action::Action)\n\nReturn a tuple of the Domains for each argument of an Action.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.blocking","page":"Internals","title":"MenuAdventures.blocking","text":"MenuAdventures.blocking(domain, parent_thing, relationship, thing)\n\nparent_thing is blocked from accessing thing via the relationship.\n\nBy default, Reachable parent_things block things they are containing if they are closed. By default, Visible parent_things block things they are containing if they are closed and not MenuAdventures.is_transparent.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.ever_possible-Tuple{Any,Any,Any}","page":"Internals","title":"MenuAdventures.ever_possible","text":"MenuAdventures.ever_possible(action::Action, domain::Domain, noun::Noun)\n\nWhether it is abstractly possible to apply an Action to a Noun from a particular Domain.\n\nFor whether it is concretely possible for the player in at a certain moment, see possible_now. Most possibilities default to false, with some exceptions, documented in specific actions.\n\nCertain possibilities come with required fields:\n\never_possible(::Open, ::Reachable, noun requires that noun has a mutable closed::Bool field.\never_possible(::Unlock, ::Reachable, noun) requires that noun has a key::Noun field and a mutable locked::Bool field.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.find_in_domain","page":"Internals","title":"MenuAdventures.find_in_domain","text":"MenuAdventures.find_in_domain(universe, sentence, domain; lit = true)\n\nReturn a vector of Answers for all things around the player in a certain Domain.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.indefinite-Tuple{Any}","page":"Internals","title":"MenuAdventures.indefinite","text":"MenuAdventures.indefinite(domain) = \"something\"\n\nPlaceholder for an object from the Domain.\n\nFor example, the indefinite for ExitDirections is \"some way\".\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.interrogative-Tuple{Any}","page":"Internals","title":"MenuAdventures.interrogative","text":"MenuAdventures.interrogative(domain) = \"something\"\n\nAsk for an object from the Domain.\n\nFor example, the interrogative for ExitDirections is \"which way\".\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_shining-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_shining","text":"is_shining(::Noun) = false\n\nWhether something provides its own light.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_transparent-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_transparent","text":"MenuAdventures.is_transparent(thing::Noun) = false\n\nWhether you can see through thing into its contents.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.is_vehicle-Tuple{Noun}","page":"Internals","title":"MenuAdventures.is_vehicle","text":"MenuAdventures.is_vehicle(::Noun) = false\n\nWhether something is a vehicle.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.look_around-NTuple{4,Any}","page":"Internals","title":"MenuAdventures.look_around","text":"MenuAdventures.look_around(universe, domain, blocking_thing, blocked_relationship)\n\nLook around a lit location.\n\nYou can overload look_around for a Noun subtype. Use Base.invoke to avoid replicating the look_around machinery.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.mention_status-Tuple{Any,Any,Any}","page":"Internals","title":"MenuAdventures.mention_status","text":"mention_status(io, action, thing)\n\nMention the status of thing corresponding to action.\n\nFor example, for the OpenOrClose action, will display whether thing is open or closed. Called for all action subtypes when mentioning a thing. Defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.opposite","page":"Internals","title":"MenuAdventures.opposite","text":"MenuAdventures.opposite(direction::Direction)\n\nThe opposite of a Direction.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MenuAdventures.possible_now-NTuple{4,Any}","page":"Internals","title":"MenuAdventures.possible_now","text":"MenuAdventures.possible_now(universe, sentence, domain, thing)\n\nWhether it is currently possible to apply sentence.action to a thing in a domain.\n\nSee ever_possible for a more abstract possibilities.  sentence will contain already chosen arguments, should you wish to access them.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.possible_now-Tuple{Any,Any}","page":"Internals","title":"MenuAdventures.possible_now","text":"possible_now(universe, action)\n\nWhether it is possible to conduct an action. Defaults to true; you can set to false for some actions without arguments.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MenuAdventures.print_sentence","page":"Internals","title":"MenuAdventures.print_sentence","text":"MenuAdventures.print_sentence(io, action::Action, argument_answers::Answer...)\n\nPrint a sentence to io.\n\nThis allows for inserting connectives like with. Arguments will be passed as Answers.\n\n\n\n\n\n","category":"function"}]
}
